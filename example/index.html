<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>Java Script Examples</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="mystyle.css">
        <script src ="javascript_concepts.js"></script>
    </head>
    <body>
        <div>
        <input type="search"/>
        <h1>Example 1: working with Strings</h1>
        <p>Hello + World string concatenation : &nbsp;<span id="demo"></span></p>
        <p>String: s = <span id="demo1"></span></p>
        <p>s.charAt(0) : &nbsp;<span id="demo2"></span></p>
        <p>s.charAt(s.length-1) : &nbsp;<span id="demo3"></span></p>
        <p>s.substring(1,4) : &nbsp;<span id="demo4"></span></p>
        <p>s.slice(1,4) : &nbsp;<span id="demo5"></span></p>
        <p>s.slice(-3) : &nbsp;<span id="demo6"></span></p>
        <p>s.indexOf('l') : &nbsp;<span id="demo7"></span></p>
        <p>s.lastIndexOf("l") : &nbsp;<span id="demo8"></span></p>
        <p>s.indexOf("l",3) : &nbsp;<span id="demo10"></span></p>
        <p>s.split(",") : &nbsp;<span id="demo9"></span></p>
        <p>s.replace("h","H") : &nbsp;<span id="demo11"></span></p>
        <p>s.toUpperCase() : &nbsp;<span id="demo12"></span></p>
        <button onclick="stringManipulation()">Click to see the result ! </button>
        <br>
        
        <h1>Example 2: Pattern Matching</h1>
        <p>text : &nbsp;<span id="demo13"></span></p>
        <p>patter : &nbsp;<span id="demo13a"></span></p>
        <p>pattern.test(text) : &nbsp;<span id="demo14"></span></p>
        <p>text.search(pattern) : &nbsp;<span id="demo15"></span></p>
        <p>text.match(pattern) : &nbsp;<span id="demo16"></span></p>
        <p>text.replace(pattern,"#") : &nbsp;<span id="demo17"></span></p>
        <p>text.split(/\D+/) : &nbsp;<span id="demo18"></span></p>
        <button onclick="patternMatching()">Click to see the result ! </button>
        <br>
        
        <h1>Example 3: Wrapper Object</h1>
        <p> String, Numbers and boolean are primitive types not objects. So when a method is called on them<br>
            a temporary object (wrapper object) is created which performs required action, produces results
            and is destroyed 
            <br>Example<br>
            var s = "test";<br>
            s.len = 4; --------------> this assignment is done on a wrapper object which is destroyed <br>
            var t = s.len<br>
            t : &nbsp;<span id="demo19"></span> --------------> there t can not access it!</p>
        <button onclick="wrapperObject()">Click to see the result ! </button>
        <br>
        
        <h1>Example 4: Immutable Objects</h1>
        <p> var immutable = "hello, world";
            <br>immutable.toUpperCase() : &nbsp;<span id="demo20"></span></p>
        <p>but the string "immutable" remains unchanged <br> immutable: &nbsp;<span id="demo21"></span>
            <br>But if we immutable = immutable.toUpperCase() then <br> immutable: &nbsp;<span id="demo22"></span> </p>
        <button onclick="immutableObjects()">Click to see the result ! </button>
        <br>
        
        <h1>Example 5: Mutable Objects</h1>
        <p>Objects are sometimes called references. Two objects are same if and only if they refer to same underlying object!<br>
            var a = [1,'#','c'];<br>
            var b = a;<br>
            b[0] = <span id="demo23"></span> <br>
            b[1] = <span id="demo24"></span> <br>
        <button onclick="mutableObjects()">Click to see result !</button><br>
        
        Here both a and b arrays reference the same object. But if we want to make  copy of array a <br><br>
        
        for(var i = 0; i < a.length; i++)<br>
            {<br>
            &nbsp;&nbsp;b[i] = a[i];<br>
            }<br>
        array b =<span id="demo25"></span> </p>
        <button onclick="printArray()">Click to see result !</button>
        
        <h1>Example 6: Type Conversions</h1>
        <p>JavaScript is very flexible about type conversion. Therefore its == (equality operator) is also flexible<br>
            if(null == undefined) evaluates to: <span id="demo26"></span>-------->both are treaded equal <br>
            if("0" == 0) evaluates to: <span id="demo27"></span>--------> String "0" is converted to number before comparison<br>
            if(0 == false) evaluates to: <span id="demo28"></span>--------> Boolean false is converted to number before comparison<br>
            if("0" == false) evaluates to: <span id="demo29"></span>--------> Both operand are converted to number before comparison<br></p>
        <button onclick="typeConversion()">Click to see result !</button>
        
        <h1>Example 7: Explicit Conversions</h1>
        <p>We can used constructors like Boolean(), String(), Number() or Objects() to perform explicit (forced by user) conversions<br>
        <em>Except for "null" and "undefined" all the other types have toString() method.</em> So if toString is applied to these two:<br>
        null.toString() = <span id="demo30"></span><br>
        undefined.toString() = <span id="demo31"></span></p>
        <button onclick="explicitConversion()">Click to see result !</button>
        
        <h1>Example 8: toString() on number</h1>
        <p>var n = 17; <br>
            n_string = n.toString();------> <span id="demo32"></span> this uses base 10<br>
            binary_string = n.toString(2);------> <span id="demo33"></span><br>
            octal_sting = n.toString(8);------> <span id="demo34"></span><br>
            hex_string = n.toString(6);------> <span id="demo35"></span><br></p>
        <button onclick="conversion()">Click to see result !</button>
        <p>Working with Financial or Scientific data we might want to convert numbers to string in such a way that it gives us control over<br> 
            the number of decimal places or number of significant digits or to use exponential notation. For such propose javascript has three<br> 
        methods defined on Number class:</p>
        <ul>
            <li>toFixed()
                <ul><li>var n = 123456.789;</li>
                <li>n.toFixed(0) = <span id ="demo36"></span></li>
                <li>n.toFixed(2) = <span id ="demo37"></span></li>
                <li>n.toFixed(5) = <span id ="demo38"></span></li></ul>
            </li>
            <li>toExponential() 
                <ul><li>var n = 123456.789;</li>
                <li>n.toExponential(1) = <span id ="demo39"></span></li>
                <li>n.toExponential(3) = <span id ="demo40"></span></li></ul>
            </li>
            <li>toPrecision() 
                <ul><li>var n = 123456.789;</li>
                <li>n.toPrecision(4) = <span id ="demo41"></span></li>
                <li>n.toPrecision(7) = <span id ="demo42"></span></li>
                <li>n.toPrecision(10) = <span id ="demo43"></span></li></ul>
            </li>
        </ul>
        <button onclick="scientific()">Click to see result !</button>
        
        <p>if you pass a string to Number(): <br>
            var s = "swati";<br>
            var num = new Number(s);<br>
            print num = <span id="demo44"></span></p>
        <button onclick="stringToNumber()">Click to see result !</button>
        
        <h1>parseInt() and parseFloat()</h1>
        <p>parseInt() and parseFloat() are more flexible</p>
            <ul><li>parseInt("3 blind mice") = <span id ="demo45"></span></li>
                <li>paseFloat(" 3.14 meters") = <span id ="demo46"></span></li>
                <li>parseInt("-12.34") = <span id ="demo47"></span></li>
                <li>parseInt("oxFF") = <span id ="demo48"></span></li>
                <li>parseInt("0xFF") = <span id ="demo49"></span></li>
                <li>parseInt("-0XFF") = <span id ="demo50"></span></li>
                <li>parseFloat(".1") = <span id ="demo51"></span></li>
                <li>parseInt("0.1") = <span id ="demo52"></span></li>
                <li>parseInt(".1") = <span id ="demo53"></span></li>
                <li>parseInt("11",2) = <span id ="demo54"></span></li>
            </ul>
        <p>parseInt() accepts an option second argument specifying radix (base)</p>
        <ul>
            <li>parseInt("11",2) = <span id ="demo55"></span>  (1*2 + 1)</li>
            <li>parseInt("ff",16 = <span id ="demo56"></span>  (15*16 + 15) </li>
            <li>parseInt("zz",36) = <span id ="demo57"></span></li>
            <li>parseInt("077",8) = <span id ="demo58"></span></li>
            <li>parseInt("077",10) = <span id ="demo59"></span></li>
        </ul>
        <p>All objects convert to true. All objects inherit two conversion methods:<br></p>
        <ol> <li>toString()
                <ol><li>toString() Array, converts array elements to string and joins them with a comma <br> 
                        [1,2,3,].toString() = <span id="demo60"></span></li>
                    <li>toString()on function, returns source code<br>
                        parseIntAndFloat().toString() = <span id ="demo61"></span></li>
                    <li>toString() on Date returns human readable date<br>
                        new Date(2010,0,1,).toString() = <span id = "demo62"></span></li>
                    <li>toString() on RegExp object converts it to string that looks like RegExp literal<br>
                        /\d+/g.toString() = <span id ="demo63"></span></li></ol></li>
            <li>valueOf() this not well defined. It tries to convert objects to a primitive value
            <ol><li>valueOf() method on array, function and RegExp returns object itself just like the default behavior </li>
                <li>Date class returns internal representation 
                    <br>var d = new Date(2010,0,1,);<br>
                    d.valueOf() = <span id="demo64"></span></li>
            </ol></li>
        </ol>
        <p>Thus in case of object to string conversion  javascript first looks for toString() and checks if it returns a <br>
            primitive value if not it looks for valueOf() and check the result for primitive value, if so converts that <br>
            value to string and returns it <br> else throws TypeError  </p>
        <p>Object to number conversion follows the same logic but javascript tries for valueOf() first.<br> 
            Because of this toString on an empty array returns number 0 and array with single element returns that element as number.</p>
        <button onclick="parseIntAndFloat()">Click to see result !</button>
        
        <p>conversion in case of + and == operators<br>
        + performs addition on numbers and string concatenation in case of strings and javascript uses a special object-to-primitive
        conversion rather than object-to-number.<br> 
        Date class is the only predefined core javascript type which has meaningful conversions for both string and numbers. </p>
        
        <h1>Example 9: Variable Scope</h1>
        <p>javascript does not have block scope instead it uses function scope. Example:<br>
            function scope(s)<br>
            {<br>
                var i = 0;<br>
                &nbsp;if(typeof s === 'object')<br>
                {<br>
                &nbsp;&nbsp;    var j = 0;<br>
                &nbsp;&nbsp;    for(var k=0; k<10; k++ )<br>
                &nbsp;&nbsp;&nbsp;{<br>
                &nbsp;&nbsp;&nbsp;&nbsp;    print k ;  ===> <span id="demo65"></span>
                    <br>
                &nbsp;&nbsp;    }<br>
            print k ;  ===> <span id="demo66"></span><br>
        }<br>
        print j ;  ===> <span id="demo67"></span><br>
}</p>
 <button onclick="scope([1,2,3])">Click to see result !</button>    
 <h2>Example 9a: Hosting</h2>
 <p> in javascript function scope means that all variables are visible within the scope of the function. that means <br>
     the variablesare visible even before they are declared! that is all the variables are hosted to the top of the function</p>
 <p>
     var scope = "global";
     function hosting()<br>{<br>
     &nbsp;&nbsp;scope = <span id="demo68"></span>&nbsp;----> because of the hosting concept the global scope variable is hidden 
     throughout the function scope! <br>
     &nbsp;&nbsp;var scope = "local";<br>
    &nbsp;&nbsp;scope = <span id="demo69"></span><br>
}<br>
<em>So to avoid such confusion some programmers declare all variables to the top of the program as opposite to languages<br> with 
    block scope where we declare variables as close as possible to where they are used with the narrows possible scope</em>
 </p>
 <button onclick="hosting()">Click to see result !</button>
 <h2>The Scope Chain</h2>
 <p>Every chunk of Javascript code has a scope chain associated with it. It is the list of objects that define the variable<br>
     in scope of that code.when javascript needs to get the value of the variable, it starts looking at the fist object in<br>
     the chain if it has that variable as property, javascript uses it else moves to the next object in the chain. It keeps<br>
     doing it until it finds the property in the chain else the variable is not in the scope for the code <br>
 and ReferenceError occurs</p>
 <p><a href="expressionAndOperators.html">next</a></p>
        </div>
    </body>
</html>
